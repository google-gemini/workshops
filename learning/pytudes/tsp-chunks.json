{
  "chunks": [
    {
      "chunk_id": "chunk-1-peter-norvig-attribution",
      "topic": "Attribution to Peter Norvig",
      "text": "<div style=\"text-align: right\" align=\"right\"><i>Peter Norvig, 2015–2023</i></div>\n---\n",
      "concepts": [],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-2-traveling-salesperson-problem-definition",
      "topic": "Introduction to the Traveling Salesperson Problem (TSP)",
      "text": "# The Traveling Salesperson Problem\n\nConsider the [***Traveling Salesperson Problem***](http://en.wikipedia.org/wiki/Traveling_salesman_problem) (abbreviated ***TSP***): \n\n- *Given a **set of cities** and the **distance** between each pair of cities, what is the **shortest** possible **tour** that visits each city exactly once, and returns to the starting city?*\n\nIn this notebook we will develop some solutions to the problem, and more generally show *how to think about* solving  problems. Versions of the algorithms developed here are used in [serious applications](https://research.googleblog.com/2016/09/the-280-year-old-algorithm-inside.html) that millions of people rely on every day. \n\n|![](http://support.sas.com/documentation/cdl/en/ornoaug/66084/HTML/default/images/map002g.png)|\n|---|\n|[An example tour, from the TSP History page](http://www.math.uwaterloo.ca/tsp/history/pictorial/dfj.html)|",
      "concepts": [
        "traveling-salesperson-problem",
        "tsp",
        "set-of-cities",
        "distance",
        "shortest-tour"
      ],
      "chunk_type": "definition"
    },
    {
      "chunk_id": "chunk-3-random-cities-function",
      "topic": "Defining the random_cities function for generating city sets",
      "text": "To test TSP algorithms, I'll need sets of cities. I'll define `random_cities(n)` to return a set of `n` cities, sprawled out randomly over the map.\n\n*Note*: I want to be able to do reproducible comparisons of algorithms: to run two or more algorithms on the same set of cities. Therefore `random_cities` has an optional argument, `seed`, with a default value. If you pass in the same seed, you will get back the same set of cities. This is true even after restarting with a different version of Python (it could possibly change with a major revision, as in Python 2 to Python 3). If you want a different set of *n* random cities, pass in a different seed.",
      "concepts": [
        "tsp-algorithms",
        "random-cities-function",
        "reproducible-results",
        "seed-value"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-4-random-cities-implementation",
      "topic": "Implementation of the random_cities function",
      "text": "```python\ndef random_cities(n, seed=1234, width=9999, height=6666) -> Cities:\n    \"\"\"Make a set of n cities, sampled uniformly from a (width x height) rectangle.\"\"\"\n    random.seed((n, seed)) # To make `random_cities` reproducible\n    return Cities(City(random.randrange(width), random.randrange(height))\n                  for c in range(n))\n```",
      "concepts": [
        "random-cities-function",
        "random-number-generation",
        "seed-value",
        "cities-object",
        "city-object"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-5-plot_tour-function",
      "topic": "Definition of the plot_tour function",
      "text": "# Visualizing results: `plot_tour`\n\nI'll define `plot_tour` to plot all the cities and links in a tour, highlighting the first city. \n\n- *Vocabulary note:* A **segment** is a portion of a tour that does not loop back to the start. The **segment** `[A, B, C]` has only two links, A-B and B-C, whereas the **tour** `[A, B, C]` has three links, A-B, B-C, and C-A.",
      "concepts": [
        "plot_tour",
        "tour",
        "segment",
        "city"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-6-plot_tour-implementation",
      "topic": "Implementation of plot_tour and helper functions",
      "text": "```python\nSegment = list # A portion of a tour; it does not loop back to the start.\n\ndef plot_tour(tour: Tour, style='bo-', hilite='rs', title=''): \n    \"Plot every city and link in the tour, and highlight the start city.\"\n    scale = 1 + len(tour) ** 0.5 // 10\n    plt.figure(figsize=((3 * scale, 2 * scale)))\n    start = tour[0]\n    plot_segment([*tour, start], style)\n    plot_segment([start], hilite) \n    plt.title(title)\n    \ndef Xs(cities) -> List[float]: \"X coordinates\"; return [c.real for c in cities]\ndef Ys(cities) -> List[float]: \"Y coordinates\"; return [c.imag for c in cities]\n\ndef plot_segment(segment: Segment, style='bo:'):\n    \"Plot every city and link in the segment.\"\n    plt.plot(Xs(segment), Ys(segment), style, linewidth=2/3, markersize=4, clip_on=False)\n    plt.axis('scaled'); plt.axis('off')\n```",
      "concepts": [
        "plot_tour",
        "tour",
        "segment",
        "city",
        "x-coordinates",
        "y-coordinates",
        "plotting"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-7-plot_tour-example-usage",
      "topic": "Example usage of plot_tour",
      "text": "```python\nplot_tour(exhaustive_tsp(random_cities(8)))\n```\n\n\n![png](TSP_files/TSP_14_0.png)\n\n\nThe plot helps convince me that this is indeed the shortest tour.",
      "concepts": [
        "plot_tour",
        "exhaustive-tsp",
        "random-cities",
        "shortest-tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-8-run-function-definition",
      "topic": "Definition of the `run` convenience function",
      "text": "# Convenience function: `run`\n\nI will define `run` to run a TSP algorithm on a set of cities, plot the resulting tour, and print the tour length and run time.",
      "concepts": [
        "run-function",
        "tsp-algorithm",
        "tour-length",
        "plotting-tour",
        "cities"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-9-run-function-implementation",
      "topic": "Implementation of the `run` function in Python",
      "text": "```python\ndef run(tsp: callable, cities: Cities):\n    \"\"\"Run a TSP algorithm on a set of cities and plot/print results.\"\"\"\n    t0   = time.perf_counter()\n    tour = tsp(cities)\n    t1   = time.perf_counter()\n    L    = tour_length(tour)\n    print(f\"length {round(L):,d} tour of {len(cities)} cities in {t1 - t0:.3f} secs\")\n    plot_tour(tour)\n```",
      "concepts": [
        "run-function",
        "tsp-algorithm",
        "tour-length",
        "plotting-tour",
        "cities",
        "time-complexity",
        "perf-counter"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-10-run-function-example",
      "topic": "Example usage of the `run` function",
      "text": "Here is `run` in action:\n\n\n```python\nrun(exhaustive_tsp, random_cities(8))\n```\n\n    length 23,470 tour of 8 cities in 0.086 secs\n\n\n\n    \n![png](TSP_files/TSP_18_1.png)",
      "concepts": [
        "run-function",
        "exhaustive-tsp",
        "random-cities",
        "tour-length",
        "plotting-tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-11-possible-tours-speedup",
      "topic": "Speedup for `possible_tours` function",
      "text": "The number of possible tours of *n* cities is the number of permutations, which is *n*! (the factorial of *n*), and thus there are  6 tours of 3 cities:\n\n```python\ntuple(possible_tours({1, 2, 3}))\n```\n\n\n\n    ((1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1))\n\n",
      "concepts": [
        "possible-tours",
        "permutations",
        "factorial",
        "tour"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-12-redundant-tour-representation",
      "topic": "Eliminating redundant tour representations",
      "text": "But a tour is a loop, so `(1, 2, 3)`, `(2, 3, 1)`, and `(3, 1, 2)` are three ways of describing exactly the same loop. I can redefine `possible_tours` to only include one representation of each loop by arbitrarily saying that a tour must start with the first city in the set of cities.  \n\n\n```python\ndef possible_tours(cities) -> List[Tour]:\n    \"\"\"Return a list of non-redundant tours (permutations of cities with first city first).\"\"\"\n    start, *others = cities\n    return [[start, *perm] for perm in itertools.permutations(others)]\n```",
      "concepts": [
        "tour",
        "loop",
        "possible-tours",
        "permutations",
        "itertools.permutations"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-13-verifying-reduced-tours",
      "topic": "Verification of the reduced number of tours",
      "text": "We can verify that for 3 cities there are now only 2 tours, not 6:\n\n\n```python\npossible_tours({1, 2, 3})\n```\n\n\n\n    [[1, 2, 3], [1, 3, 2]]\n\n",
      "concepts": [
        "possible-tours",
        "tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-14-exhaustive-tsp-performance-9-cities",
      "topic": "Performance of `exhaustive_tsp` with 9 cities",
      "text": "We can see that `exhaustive_tsp` can now do 9 cities in roughly the time it took to do 8 before:\n\n\n```python\nrun(exhaustive_tsp, random_cities(9))\n```\n\n    length 22,412 tour of 9 cities in 0.151 secs\n\n\n\n\n![png](TSP_files/TSP_26_1.png)\n    ",
      "concepts": [
        "exhaustive-tsp",
        "random-cities"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-15-exhaustive-tsp-performance-10-cities",
      "topic": "Performance of `exhaustive_tsp` with 10 cities",
      "text": "We can keep going to 10 cities, which takes about a second:\n\n\n```python\nrun(exhaustive_tsp, random_cities(10))\n```\n\n    length 23,013 tour of 10 cities in 0.870 secs\n\n\n\n\n![png](TSP_files/TSP_28_1.png)",
      "concepts": [
        "exhaustive-tsp",
        "random-cities"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-16-tsp-algorithm-strategies-introduction",
      "topic": "Introduction to Algorithm Design Strategies for TSP",
      "text": "It takes Exhaustive Search a second or so to solve a 10-city problem, so 12 cities would take about 2 minutes (11×12 times longer), and 15 cities would take days.\nThere must be a better way ...",
      "concepts": [
        "traveling-salesperson-problem",
        "algorithm-design",
        "exhaustive-search"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-17-algorithm-design-strategies-list",
      "topic": "Listing of General Algorithm Design Strategies",
      "text": "To get inspired, here are some general  strategies for algorithm design:\n\n* **Brute Force Strategy**: The strategy used for `exhaustive_tsp`; as [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson) [says](https://www.brainyquote.com/quotes/ken_thompson_185574?src=t_brute_force), \"*when in doubt, use brute force*.\"\n* **Approximation Strategy**: If it is too hard to find an exact, optimal solution, consider an approximate, slightly suboptimal solution.\n* **Greeedy Strategy**: To complete a multiple step problem, first do the step that appears to be best in the short run. Repeat.\n* **Improvement Strategy**: Use an existing algorithm to create a solution, then have another algorithm improve the solution.\n* **Divide and Conquer Strategy**: Split the problem in half, solve each half, and combine the two partial solutions.\n* **Ensemble Strategy**: Apply a set of algorithms to the problem, and pick the best solution.\n* **Stand on the Shoulders of Giants Strategy**: Find out what other people have done, and copy them.\n\nLet's apply these strategies to develop some TSP algorithms.",
      "concepts": [
        "algorithm-design",
        "brute-force-strategy",
        "approximation-strategy",
        "greedy-strategy",
        "improvement-strategy",
        "divide-and-conquer-strategy",
        "ensemble-strategy",
        "traveling-salesperson-problem"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-18-nearest-neighbor-tsp-algorithm-definition",
      "topic": "Definition of the Nearest Neighbor TSP Algorithm",
      "text": "#  Nearest Neighbor Algorithm: `nearest_tsp`\n\nHere's a second TSP algorithm:\n\n- **Nearest Neighbor TSP Algorithm:** *Create a partial tour that initially is just the start city. At each step extend the partial tour to the nearest unvisited neighbor of the last city in the partial tour, until there are no unvisited cities remaining.*\n\nThis is both an **approximation strategy** and a **greedy strategy**. It is an approximation, because it won't necessarily find the optimal tour. It is greedy because at each step it makes the choice that looks best in the short run (the nearest neighbor), even if that is not the best in the long run.",
      "concepts": [
        "nearest-neighbor-tsp-algorithm",
        "approximation-strategy",
        "greedy-strategy",
        "traveling-salesperson-problem"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-19-nearest-neighbor-tsp-algorithm-implementation",
      "topic": "Python implementation of the Nearest Neighbor TSP Algorithm",
      "text": "```python\ndef nearest_tsp(cities, start=None) -> Tour:\n    \"\"\"Create a partial tour that initially is just the start city. \n    At each step extend the partial tour to the nearest unvisited neighbor \n    of the last city in the partial tour, while there are unvisited cities remaining.\"\"\"\n    start = start or first(cities)\n    tour = [start]\n    unvisited = set(cities) - {start}\n    def extend_to(C): tour.append(C); unvisited.remove(C)\n    while unvisited:\n        extend_to(nearest_neighbor(tour[-1], unvisited))\n    return tour\n\ndef first(collection):\n    \"\"\"The first element of a collection.\"\"\"\n    return next(iter(collection))\n\ndef nearest_neighbor(A: City, cities) -> City:\n    \"\"\"Find the city C in cities that is nearest to city A.\"\"\"\n    return min(cities, key=lambda C: distance(C, A))\n```",
      "concepts": [
        "nearest-neighbor-tsp-algorithm",
        "tour",
        "city",
        "nearest-neighbor",
        "data-structures",
        "algorithms"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-20-nearest-neighbor-tsp-algorithm-complexity-and-performance",
      "topic": "Complexity and Performance Comparison",
      "text": "The exhaustive search considers all tours, so the run time for *n* cities is proportional to *n*! and [we say](https://en.wikipedia.org/wiki/Big_O_notation) it is *O*(*n*!). The nearest neighbor algorithm builds *n* links in the tour and at each step considers up to *n* possibilities, so we say it is *O*(*n*<sup>2</sup>). That means it runs a lot faster! While `exhaustive_tsp` could only do 10 cities in a second, `nearest_tsp` can do thousands. Here it is with 3,000 cities:",
      "concepts": [
        "time-complexity",
        "big-o-notation",
        "nearest-neighbor-tsp-algorithm",
        "exhaustive-search",
        "algorithms"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-21-nearest-neighbor-tsp-algorithm-example-3000-cities",
      "topic": "Example run with 3000 cities",
      "text": "```python\nrun(nearest_tsp, random_cities(3000))\n```\n\n    length 410,442 tour of 3000 cities in 0.682 secs\n\n\n\n    \n![png](TSP_files/TSP_33_1.png)",
      "concepts": [
        "nearest-neighbor-tsp-algorithm",
        "tour",
        "city",
        "algorithms"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-22-real-cities-introduction",
      "topic": "Introduction to the real cities problem",
      "text": "A tour of 3,000 random cities may look like a [Jackson Pollack](https://www.moma.org/artists/4675) painting, but I thought it would be fun to work on some *real* cities. I found a web page (now 404, but a copy is [here](https://raw.githubusercontent.com/norvig/pytudes/master/data/latlong.htm)) that lists coordinates of over 1000 cities in the USA (actually, the locations of airports in these cities), in this format:\n\n     [TCL]  33.23   87.62  Tuscaloosa,AL\n     [FLG]  35.13  111.67  Flagstaff,AZ\n     [ANC]  61.17  150.02  Anchorage,AK",
      "concepts": [],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-23-city-data-fetching",
      "topic": "Fetching city data",
      "text": "We can fetch the file if a local copy is not already in the current directory:\n\n\n```python\n! [ -e latlong.htm ] || curl -O https://raw.githubusercontent.com/norvig/pytudes/master/data/latlong.htm\n```",
      "concepts": [],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-24-city-parsing-function",
      "topic": "Parsing city data from a file",
      "text": "I define the function `parse_cities` to extract cities from a file in this format (skipping Alaska and Hawaii):\n\n\n```python\ndef parse_cities(text, skip=('AK', 'HI'), long_scale=-48, lat_scale=69) -> Cities:\n    \"\"\"Make a set of Cities from lines of text, skipping the specified states.\"\"\"\n    return Cities(City(int(long_scale * float(long)), int(lat_scale  * float(lat)))\n                  for (lat, long, state) in re.findall(r'([\\d.]+)\\s+([\\d.]+).+([A-Z][A-Z])', text)\n                  if state not in skip)\n\nUSA = parse_cities(pathlib.Path('latlong.htm').read_text())\n```",
      "concepts": [
        "parse-cities-function",
        "regular-expressions"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-25-latitude-longitude-scaling",
      "topic": "Explanation of latitude and longitude scaling",
      "text": "(You might be wondering about the `long_scale=-48, lat_scale=69` part. The issue is that computing distance from latitude and longitude requires [complicated trigonometry](http://en.wikipedia.org/wiki/Haversine_formula).  But we can get an approximation by assuming that latitude and longitude are on a flat rectangular grid. (This is a bad approximation if you're talking about links of 1,000 miles, but close enough for shorter links, as long as you're not too near the poles.)  I took the latitude of the center of the USA (Wichita, KS: latitude 37.65) and plugged it into a [Length Of A Degree Of Latitude\nAnd Longitude Calculator](http://www.csgnetwork.com/degreelenllavcalc.html) to find that, in Wichita, one degree of latitude is 69 miles, and one degree of longitude is 48 miles.  I use -48 rather than +48 because the USA is west of the prime meridian.)",
      "concepts": [
        "latitude",
        "longitude",
        "haversine-formula",
        "distance-approximation"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-26-alternative-tour-approaches",
      "topic": "Alternative tour approaches and resources",
      "text": "I also found a [blog post](http://www.randalolson.com/2015/03/08/computing-the-optimal-road-trip-across-the-u-s/) by Randal S. Olson, who chose 50 landmarks across the USA and found a tour based on actual road-travel distances, not straight-line distance; I would need a new `distance` function to handle that. William Cook provides an\nanalysis, and a [tour that is shorter](http://www.math.uwaterloo.ca/tsp/usa50/index.html) than Randal's.",
      "concepts": [
        "traveling-salesperson-problem",
        "road-travel-distance",
        "straight-line-distance"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-27-nearest-neighbor-tour-example",
      "topic": "Nearest neighbor tour example",
      "text": "Now let's find a baseline nearest neighbor tour on the USA map:\n\n\n```python\nrun(nearest_tsp, USA)\n```\n\n    length 53,364 tour of 1088 cities in 0.082 secs\n\n\n\n    \n![png](TSP_files/TSP_40_1.png)",
      "concepts": [
        "nearest-neighbor-algorithm",
        "traveling-salesperson-problem"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-28-optimizing-links-introduction",
      "topic": "Introduction to optimizing links in TSP tours",
      "text": "# Improvement Strategy: Optimizing Links\n\nConsider this tour of 10 non-random cities:\n\n```python\nx10 = Tour(City(x, 0.9) for x in range(0, 5)) + Tour(City(x, 0) for x in range(4, 9))\n\nplot_tour(rep_nearest_tsp(Cities(x10)))\n```\n\n\n    \n![png](TSP_files/TSP_52_0.png)\n    ",
      "concepts": [
        "traveling-salesperson-problem",
        "tsp-tour",
        "nearest-neighbor-search"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-29-improvement-strategy",
      "topic": "Explanation of the improvement strategy for TSP",
      "text": "No matter where `rep_nearest_tsp` starts, it ends up greeedily going to nearest neighbors and being stuck with a long diagonal link to get back to the other end; that long link is a mistake.\n\nCould we modify nearest neighbors search to avoid making mistakes like this? That would be hard. Everything appears to be going well until we are forced to take the long diagonal link; we can't easily say which links before that are mistakes to avoid.  So, rather than tackling the difficult task of **avoiding** mistakes, the **improvement strategy** says to go ahead and make mistakes in creating the initial version of a tour, and then do the easier task of **fixing** the mistakes. Why is it easier to fix the mistakes? Because we can propose an alteration and get a definitive answer: either the change makes the whole tour shorter or it doesn't.",
      "concepts": [
        "improvement-strategy",
        "nearest-neighbor-search",
        "tsp-tour"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-30-2-opt-optimization",
      "topic": "Introduction to 2-opt optimization using link swapping",
      "text": "In the diagram below, we propose altering the tour above by replacing the two red links with new green links.  If the total distance of the two green links is less than the total distance of the two red links, then we should make the alteration. \n\n```python\nA, _, _, _, E, F, _, _, _, J = x10\nplot_tour(x10, 'bo-')\nplot_segment([E, F], 'r-');  plot_segment([E, J], 'g-')\nplot_segment([A, J], 'r-');  plot_segment([A, F], 'g-')\n```\n\n\n    \n![png](TSP_files/TSP_54_0.png)\n    \n\nWhen we are dealing with **Euclidean distance** (or any **[metric space](https://en.wikipedia.org/wiki/Metric_space)** for that matter), then by the [triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality) we can see that each green line is shorter than the sum of the two parts of the red lines that make up the rest of the triangle; thus we should make the alteration, and in general, anytime there are two links that **cross** in an **X** pattern, we should uncross the **X**. (With a non-Euclidean distance measure, the 2-opt optimizations still work, but the **crossed X** analogy does not apply.)\n\nYou can think of the alteration as deleting the two red links and adding the two green ones. Or you can think of it as **reversing a segment** of the tour: the crossed-links tour visits the top 5 cities in left-to-right order, then jags down to the bottom 5 cities, visiting them in left-to-right order. A better tour would visit the bottom five in right-to-left order. (Note that the total distance for a reversed segment is the same as the unreversed segment, because our `distance` is **symmetric**. If we were dealing with a non-symmetric `distance` function, we would have to keep track, for each segment, of the difference between traversing it one direction or the other, and incorporate that into the decision of whether reversing is an improvement.)\n\nIn the literature of TSP, this kind of improvement is called [**2-opt**](https://en.wikipedia.org/wiki/2-opt), because it involves deleting two links and replacing them with **two optimized** links. There is also a [**3-opt**](https://en.wikipedia.org/wiki/3-opt), which we won't cover, but you are welcome to look into it.",
      "concepts": [
        "euclidean-distance",
        "metric-space",
        "triangle-inequality",
        "2-opt",
        "3-opt",
        "tsp-tour"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-31-opt2-function-definition",
      "topic": "Definition of the opt2 function for 2-opt optimization",
      "text": "I'll define `opt2(tour)` to consider various segments, and reverse the ones that improve the tour. What segments should we consider? I don't know how to be clever about that, but I do know how to use **brute force**: try every subsegment. (I have an intuition (from experience with [simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing)) that trying longer subsegments first would be better, so I'll write `subsegments` that way.) After I've tried all segments, if one of them did improve the tour I'll repeat the process until there are no improvements, then return the improved tour:\n\n```python\ndef opt2(tour) -> Tour:\n    \"\"\"Perform 2-opt segment reversals to optimize tour.\"\"\"\n    changed = False\n    old_tour = list(tour) # make a copy\n    for (i, j) in subsegments(len(tour)):\n        if reversal_is_improvement(tour, i, j):\n            tour[i:j] = reversed(tour[i:j])\n            changed = True\n    return (tour if not changed else opt2(tour))\n        \ndef reversal_is_improvement(tour, i, j) -> bool:\n    \"\"\"Would reversing the segment `tour[i:j]` make the tour shorter?\"\"\" \n    # Given tour [...A,B--C,D...], would reversing B--C make the tour shorter?\n    A, B, C, D = tour[i-1], tour[i], tour[j-1], tour[j % len(tour)]\n    return distance(A, B) + distance(C, D) > distance(A, C) + distance(B, D)\n\ncache = functools.lru_cache(None) # Or just `functools.cache` in Python 3.9+\n        \n@cache # All tours of length N have the same subsegments, so cache them.\ndef subsegments(N) -> Tuple[Tuple[int, int]]:\n    \"\"\"Return (i, j) index pairs denoting tour[i:j] subsegments of a tour of length N.\"\"\"\n    return tuple((i, i + length)\n                 for length in reversed(range(2, N - 1))\n                 for i in range(N - length))\n```",
      "concepts": [
        "2-opt",
        "brute-force",
        "simulated-annealing",
        "lru-cache",
        "segment-reversal",
        "tsp-tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-32-opt2-function-application",
      "topic": "Applying the opt2 function to the 10-city tour",
      "text": "We can see that `opt2` does the trick on the 10 cities:\n\n```python\nplot_tour(opt2(x10))\n```\n\n\n    \n![png](TSP_files/TSP_58_0.png)\n    ",
      "concepts": [
        "2-opt",
        "tsp-tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-33-tools-for-comparing-results-introduction",
      "topic": "Introduction to comparing algorithms",
      "text": "We're about to get into comparing different algorithms, with and without `opt2`.\n\nI will rewrite `run` to perform a longer list of duties:\n\n- As before, `run` will **run** a TSP algorithm on a set of cities, **timing** how long it takes.\n- I will make `Tour` be a class, that inherits from `list`, but can be annotated with \n- Each `run` will **annotate** the save and return a **`Result`** object describing the run, the resulting tour, and the run time.\n- If an **optimization function** is specified with the `opt` parameter, first run the unoptimized version, save the result for it, then run the optimizer and save that result, with the added run time.\n- A **`@cache`** of results means a previously-run result can just be fetched, saving run time.\n- I'll add an **`assert`** statement to verify the tour is valid.\n- Plotting results will no longer be the responsibility of `run`; instead call `plot_result(result)`.\n- The function `runs` does a run for each of several TSP algorithms, then calls `plot` for the last one, and returns a list of all the results on the input cities.",
      "concepts": [
        "tsp-algorithm",
        "optimization-function",
        "caching",
        "assertion"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-34-result-class-and-helper-functions",
      "topic": "Defining the Result class and helper functions",
      "text": "```python\nclass Result(namedtuple('_', 'tsp, opt, tour, cities, secs')):\n    \"\"\"A `Result` records the results of a `run` on a TSP.\"\"\"\n    def __repr__(self): \n        best = min([length(r) for r in all_results[self.cities]], default=length(self))\n        return (f\"{name(self.tsp, self.opt):>25}: length {round(length(self)):,d} tour \"\n                f\"({length(self)/best:5.1%}) in {self.secs:6.3f} secs\")   \n\nall_results = defaultdict(list) # {cities: [tour, ...]}\n\ndef name(tsp, opt=None) -> str: return tsp.__name__ + (('+' + opt.__name__) if opt else '')\n    \ndef length(result: Result) -> float: return tour_length(result.tour)\n```",
      "concepts": [
        "result-class",
        "namedtuple",
        "defaultdict",
        "tour-length"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-35-run-function-definition",
      "topic": "Defining the run function",
      "text": "```python\n@cache\ndef run(tsp: TSP, cities: Cities, opt=None) -> Result:\n    \"\"\"Run a TSP algorithm on a set of cities and return results.\"\"\"\n    if opt: # recursively run unoptimized version; add .secs for that to opt(tour)\n        res0  = run(tsp, cities, None)\n        t0    = time.perf_counter()\n        tour  = opt(Tour(res0.tour))\n        t1    = time.perf_counter()\n        secs  = res0.secs + t1 - t0\n    else: # run the tsp\n        t0    = time.perf_counter()\n        tour  = tsp(cities)\n        t1    = time.perf_counter()\n        secs  = t1 - t0\n    result = Result(tsp, opt, tour, cities, secs)\n    all_results[cities].append(result)\n    assert valid_tour(tour, cities)\n    return result\n```",
      "concepts": [
        "run-function",
        "tsp-algorithm",
        "caching",
        "time-complexity",
        "assertion",
        "recursion"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-36-runs-function-definition",
      "topic": "Defining the runs function",
      "text": "```python\ndef runs(tsps, cities, opts=(None, opt2)) -> List[Result]:\n    \"\"\"Run each of the tsps on the cities, and return a list of all results on `cities`.\"\"\"\n    for tsp, opt in itertools.product(tsps, opts):\n        run(tsp, cities, opt)\n    all_results[cities].sort(key=length)\n    best = all_results[cities][0]\n    plot_tour(best.tour, title=repr(best))\n    return all_results[cities]\n```",
      "concepts": [
        "runs-function",
        "tsp-algorithm",
        "itertools.product",
        "sorting",
        "tour-plotting"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-37-comparing-2-opt-optimizations",
      "topic": "Comparing 2-opt optimizations with nearest neighbor algorithm variations",
      "text": "# Comparing 2-opt Optimizations\n\nNow that we have the 2-opt optimization function, let's run it on four variations of the nearest neighbor algorithm:\n1. `Tour` (run nearest neighbor zero times (just take the cities in given order), then 2-opt)\n2. `nearest_tsp` (run nearest neighbor once, then 2-opt)\n3. `rep_nearest` (run nearest neighbor k=10 times, then 2-opt)\n4. `rep_opt2_nearest_tsp` (run nearest neighbor followed by 2-opt, k=10 times)\n\nLet's see:",
      "concepts": [
        "2-opt-optimization",
        "nearest-neighbor-algorithm",
        "tour",
        "nearest-tsp",
        "rep-nearest",
        "rep-opt2-nearest-tsp"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-38-rep-opt2-nearest-tsp-function",
      "topic": "Definition and usage of the rep_opt2_nearest_tsp function",
      "text": "```python\ndef rep_opt2_nearest_tsp(cities, k=10) -> Tour: \n    \"\"\"Apply 2-opt to *each* of the repeated nearest neighbors tours.\"\"\"\n    return shortest(opt2(nearest_tsp(cities, start)) for start in sample(cities, k))\n\nruns([Tour, nearest_tsp, rep_nearest_tsp, rep_opt2_nearest_tsp], USA) \n```",
      "concepts": [
        "rep-opt2-nearest-tsp",
        "2-opt-optimization",
        "nearest-neighbor-algorithm",
        "tour",
        "shortest",
        "sample"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-39-2-opt-optimization-results",
      "topic": "Analysis of the 2-opt optimization results",
      "text": "```\n[     rep_opt2_nearest_tsp: length 44,317 tour (100.0%) in 16.662 secs,\n     rep_opt2_nearest_tsp+opt2: length 44,317 tour (100.0%) in 16.995 secs,\n          rep_nearest_tsp+opt2: length 44,473 tour (100.4%) in  2.137 secs,\n              nearest_tsp+opt2: length 45,105 tour (101.8%) in  1.768 secs,\n                     list+opt2: length 46,460 tour (104.8%) in  2.929 secs,\n               rep_nearest_tsp: length 50,915 tour (114.9%) in  0.798 secs,\n                   nearest_tsp: length 53,364 tour (120.4%) in  0.080 secs,\n                          list: length 1,122,001 tour (2531.8%) in  0.000 secs]\n```\n\n![png](TSP_files/TSP_62_1.png)\n\nI notice that:\n- `opt2` makes a **big** difference; all the optimized results are better than all the unoptimized ones.\n- The best result is the one that calls `opt2` the most: `rep_opt2_nearest_tsp` does 10 nearest neighbor trials and calls `opt2` on each one.\n- An `opt2` application on 1088 cities takes about a couple of seconds; a `nearest_tsp` application only about 0.1 seconds.\n- We should be happy to have saved 9,000 miles of travel (between the worst and best results) in 20 seconds of computing time; that's 1.6 million miles per hour!",
      "concepts": [
        "2-opt-optimization",
        "nearest-neighbor-algorithm",
        "rep-opt2-nearest-tsp",
        "tour-length",
        "optimization-performance"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-40-greedy-tsp-algorithm-introduction",
      "topic": "Introduction to the Greedy TSP Algorithm",
      "text": "# Greedy TSP Algorithm: `greedy_tsp`\n\nLet's return to the **greedy strategy**. The Nearest Neighbor Algorithm followed the greedy strategy in always choosing the neighbor that is nearest to the previous city in the tour. Another way to be greedy is to at each step incorporate the shortest possible link, **anywhere** in the map, not just from the previous city in the partial tour. It works like this:\n\n> **Greedy Algorithm:** *Maintain a set of **segments**; intially each city defines its own 1-city segment. Find the shortest possible link that connects two endpoints of two different segments, and join those segments with that link. Repeat until we form a single segment that tours all the cities.*",
      "concepts": [
        "greedy-strategy",
        "greedy-tsp-algorithm",
        "nearest-neighbor-algorithm",
        "segments"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-41-greedy-tsp-algorithm-explanation",
      "topic": "Explanation of the Greedy TSP Algorithm",
      "text": "On each step of the algorithm, we want to *\"find the shortest possible link that connects two endpoints.\"* That seems like an expensive operation to do on each step. So we will add some data structures  to speed up the computation:\n\n1. Pre-compute a list of links, sorted by shortest link first. A link is a pair of cities: `(A, B)`.\n2. Maintain a dict that maps **endpoints** to **segments**, e.g. `{A: [A, B, C], C: [A, B, C], D: [D]}` means that `A` and `C` are the endpoints of segment `[A, B, C]` and `D` is the only endpoint of a 1-city segment. \n3. Go through the links in shortest-distance-first order. Given the dict listed above, suppose the next shortest link is:\n    - `(B, D)`: We can't use it, because `B` is in the middle of a segment; it is already attached to `A` and `C`, and by definition, those are shorter links. \n    - `(A, C)`: We can't use it; that would make `[A, B, C]` into a closed loop. \n    - `(C, D)`: We will use it: join the two segments together, giving the updated endpoints dict: `{A: [A, B, C, D], D: [A, B, C, D]}`.\n4. Stop when the newly created segment contains all the cities.",
      "concepts": [
        "greedy-tsp-algorithm",
        "links",
        "endpoints",
        "segments",
        "shortest-link"
      ],
      "chunk_type": "explanation"
    },
    {
      "chunk_id": "chunk-42-greedy-tsp-algorithm-code",
      "topic": "Code implementation of the Greedy TSP Algorithm",
      "text": "Here is the code:\n\n\n```python\ndef greedy_tsp(cities):\n    \"\"\"Go through links, shortest first. If a link can join segments, do it.\"\"\"\n    endpoints = {C: [C] for C in cities} # A dict of {endpoint: segment}\n    links = itertools.combinations(cities, 2)\n    for (A, B) in shortest_links_first(cities):\n        if A in endpoints and B in endpoints and endpoints[A] != endpoints[B]:\n            joined_segment = join_segments(endpoints, A, B)\n            if len(joined_segment) == len(cities):\n                return joined_segment\n            \ndef shortest_links_first(cities) -> List[Link]:\n    \"Return all links between cities, sorted shortest first.\"\n    return sorted(itertools.combinations(cities, 2), key=lambda link: distance(*link))\n```",
      "concepts": [
        "greedy-tsp-algorithm",
        "endpoints",
        "segments",
        "shortest-links-first",
        "links"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-43-join-segments-function",
      "topic": "Explanation of the join_segments function",
      "text": "**Note:** The `endpoints` dict serves two purposes. First, the keys of the dict are cities that are endpoints of some segment, making it possible to ask \"`A in endpoints`\" to see if city `A` is an endpoint. Second, the value of `endpoints[A]` is the segment that `A` is an endpoint of, making it possible to ask \"`endpoints[A] != endpoints[B]`\" to make sure that the two cities are endpoints of different segments, not of the same segment (we don't want to join a segment to itself and form a loop).\n\nFor the `join_segments` function, I first make sure that `A` is the last element of one segment and `B` is the first element of the other, by reversing segments if necessary.  Then I add the B segment on to the end of the A segment. Finally, I update the `endpoints` dict by deleting `A` and `B` and then adding the two endpoints of the new segment:",
      "concepts": [
        "endpoints-dictionary",
        "segment-joining",
        "data-structures"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-44-join-segments-code",
      "topic": "Code implementation of join_segments",
      "text": "```python\ndef join_segments(endpoints, A, B):\n    \"\"\"Join segments [...,A] + [B,...] into one segment. Maintain `endpoints`.\"\"\"\n    Aseg, Bseg = endpoints[A], endpoints[B]\n    if Aseg[-1] is not A: Aseg.reverse()\n    if Bseg[0]  is not B: Bseg.reverse()\n    Aseg += Bseg\n    del endpoints[A], endpoints[B] \n    endpoints[Aseg[0]] = endpoints[Aseg[-1]] = Aseg\n    return Aseg\n```",
      "concepts": [
        "join-segments-function",
        "endpoints-dictionary",
        "segment-manipulation"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-45-greedy-tsp-algorithm-evaluation",
      "topic": "Evaluating greedy_tsp with and without 2-opt",
      "text": "Let's try out the `greedy_tsp` algorithm, with and without 2-opt, on the USA map:\n\n\n```python\nruns([greedy_tsp], USA)\n```\n\n\n    [     rep_opt2_nearest_tsp: length 44,317 tour (100.0%) in 16.662 secs,\n     rep_opt2_nearest_tsp+opt2: length 44,317 tour (100.0%) in 16.995 secs,\n               greedy_tsp+opt2: length 44,417 tour (100.2%) in  2.162 secs,\n          rep_nearest_tsp+opt2: length 44,473 tour (100.4%) in  2.137 secs,\n              nearest_tsp+opt2: length 45,105 tour (101.8%) in  1.768 secs,\n                     list+opt2: length 46,460 tour (104.8%) in  2.929 secs,\n               rep_nearest_tsp: length 50,915 tour (114.9%) in  0.798 secs,\n                    greedy_tsp: length 51,129 tour (115.4%) in  0.407 secs,\n                   nearest_tsp: length 53,364 tour (120.4%) in  0.080 secs,\n                          list: length 1,122,001 tour (2531.8%) in  0.000 secs]\n\n\n\n    \n![png](TSP_files/TSP_69_1.png)\n    \n\nThis time I notice that:\n- Without 2-opt, the greedy algorithm performs poorly, but better than nearest neighbors.\n- With 2-opt, the greedy algorithm is comparable (in run time and tour length) to the 10-repetition nearest neighbors algorithm.\n- To really decide which algorithm is better, we'll need more than just one problem. Latter we will **benchmark** algorithms on multiple problems.\n\nWhat about a repetitive greedy algorithm?  That might be a good idea, but there is no obvious way to do it, because the greedy algorithm as it stands doesn't have a parameter that can be varied on each repeated run.",
      "concepts": [
        "greedy-tsp-algorithm",
        "2-opt-optimization",
        "nearest-neighbors-algorithm",
        "benchmarking"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-46-visualizing-greedy-algorithm",
      "topic": "Introduction to visualizing the greedy algorithm",
      "text": "## Visualizing the Greedy Algorithm\n\nI would like to visualize the process of joining segments.  Although I dislike copy-and-paste (because it violates the [*Don't Repeat Yourself*](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle), I'll  make a new version of `greedy_tsp` called `greedy_tsp_generator` that yields the `endpoints` dict on every iteration. Then I'll define `plot_greedy_tsp` to plot progressive versions of the map when the number of segments hits certain milestones.",
      "concepts": [
        "greedy-tsp-algorithm",
        "visualization",
        "dont-repeat-yourself-principle"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-47-greedy-tsp-generator-and-plot-greedy-tsp-code",
      "topic": "Code for visualizing the greedy TSP algorithm",
      "text": "```python\ndef greedy_tsp_generator(cities) -> Iterable[Dict[City, Segment]]:\n    \"\"\"Go through links, shortest first. If a link can join segments, do it.\n    Yield the dict of {endpoint: segment} on each iteration.\"\"\"\n    endpoints = {C: [C] for C in cities} # A dict of {endpoint: segment}\n    links = itertools.combinations(cities, 2)\n    for (A, B) in sorted(links, key=lambda link: distance(*link)):\n        if A in endpoints and B in endpoints and endpoints[A] != endpoints[B]:\n            joined_segment = join_segments(endpoints, A, B)\n            yield endpoints\n            if len(joined_segment) == len(cities):\n                return\n\ndef plot_greedy_tsp(cities, plot_sizes=(1000, 500, 250, 125, 60, 30, 15, 10, 5, 2, 1)):\n    \"\"\"Plot segments during the process of `greedy_tsp`, at specified plot_sizes.\"\"\"\n    for endpoints in greedy_tsp_generator(cities):\n        segments = set(map(tuple, endpoints.values()))\n        if len(segments) in plot_sizes:\n            for s in segments:\n                plot_segment(s, style='o-')\n            plt.title(f'{len(segments)} segments:')\n            plt.show()\n```",
      "concepts": [
        "greedy-tsp-algorithm",
        "visualization",
        "greedy-tsp-generator",
        "plot-greedy-tsp",
        "endpoints-dictionary"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-48-visualizing-greedy-tsp-on-usa360",
      "topic": "Visualizing the greedy TSP algorithm on a subset of US cities",
      "text": "The full USA map would be too busy to see what's going on, so I'll sample about 1/3 of the cities:\n\n\n```python\nUSA360 = Cities(sample(USA, 360))\n\nplot_greedy_tsp(USA360)\n```\n\n\n    \n![png](TSP_files/TSP_73_0.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_1.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_2.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_3.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_4.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_5.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_6.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_7.png)\n    \n\n\n    \n![png](TSP_files/TSP_73_8.png)\n",
      "concepts": [
        "greedy-tsp-algorithm",
        "visualization",
        "sampling",
        "usa360-dataset"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-49-split-cities-algorithm",
      "topic": "Splitting cities based on coordinates",
      "text": "How do we split a set of cities?  In the non-Euclidean case, there would be no easy way to make a good split. But with each city having *x* and *y* coordinates, \nmy approach is to imagine drawing an axis-aligned rectangle that is just big enough to contain all the cities. If the rectangle  is wider than it is tall, then order all the cities by *x* coordinate and split that ordered list in half.  If the rectangle is taller than it is wide, order and split the cities by *y* coordinate.",
      "concepts": [
        "split-cities",
        "axis-aligned-rectangle",
        "x-coordinate",
        "y-coordinate"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-50-split-cities-implementation",
      "topic": "Python implementation of split_cities",
      "text": "```python\ndef X_(city) -> int: \"X coordinate\"; return city.real\ndef Y_(city) -> int: \"Y coordinate\"; return city.imag\n\ndef split_cities(cities) -> Tuple[List[City], List[City]]:\n    \"Split cities vertically if map is wider; horizontally if map is taller.\"\n    coord  = (X_ if (extent(Xs(cities)) > extent(Ys(cities))) else Y_)\n    cities = sorted(cities, key=coord)\n    middle = len(cities) // 2\n    return cities[:middle], cities[middle:]\n\ndef extent(numbers) -> float: return max(numbers) - min(numbers)\n```",
      "concepts": [
        "split-cities",
        "x-coordinate",
        "y-coordinate",
        "sorting",
        "extent"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-51-joining-tours-algorithm",
      "topic": "Joining two tours together",
      "text": "Now for the tricky part: joining two tours together. First we consider all ways of deleting one link from each of the two tours.  If we delete a link from a tour we get a segment.  We are representing segments as lists of cities, the same surface representation as tours.  But there is a difference in their interpretation.  The tour `[C, A, B]` is a triangle of three links, but the segment `[C, A, B]` consists of only two links, from `C` to `A` and from `A` to `B`. The segments that result from deleting a link from the tour `[C, A, B]` are:\n\n     [C, A, B],  [A, B, C],  [B, C, A]\n\nYou may recognize these as the *rotations* of the segment `[C, A, B]`. So any candidate combined tour consists of taking a rotation of the first tour, and appending to it a rotation of the second tour, with one caveat: when we go to append the two segments, there are two ways of doing it: either keep the second segment as is, or reverse the second segment.",
      "concepts": [
        "join-tours",
        "tour-segment",
        "tour-rotation",
        "link-deletion"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-52-join-tours-implementation",
      "topic": "Python implementation of join_tours",
      "text": "```python\ndef join_tours(tour1, tour2):\n    \"Consider all ways of joining the two tours together, and pick the shortest.\"\n    segments1, segments2 = rotations(tour1), rotations(tour2)\n    return shortest(s1 + s3\n                    for s1 in segments1\n                    for s2 in segments2\n                    for s3 in (s2, s2[::-1]))\n\ndef rotations(sequence):\n    \"All possible rotations of a sequence.\"\n    # A rotation is some suffix of the sequence followed by the rest of the sequence.\n    return [sequence[i:] + sequence[:i] for i in range(len(sequence))]\n```",
      "concepts": [
        "join-tours",
        "tour-rotation",
        "shortest-path",
        "sequence-rotation"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-53-divide-and-conquer-example-a-f",
      "topic": "Divide and conquer example with cities A to F",
      "text": "Let's divide and conquer! First the 6 cities `A` to `F`:\n\n\n```python\nruns([divide_tsp], Cities(A2F))\n```\n\n\n\n    [               divide_tsp: length 12 tour (100.0%) in  0.000 secs,\n               divide_tsp+opt2: length 12 tour (100.0%) in  0.000 secs]\n\n\n\n    \n![png](TSP_files/TSP_87_1.png)\n    ",
      "concepts": [
        "divide-and-conquer",
        "divide-tsp",
        "optimization",
        "traveling-salesman-problem"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-54-divide-and-conquer-example-usa",
      "topic": "Divide and conquer example with USA cities",
      "text": "Now the USA map. But the `divide_tsp` algorithm, as I have written it, is slow. So I'll use the smaller sample of cities from USA, and compare `divide_tsp` to `greedy_tsp`, with and without `opt2`:\n\n\n```python\nruns([divide_tsp, greedy_tsp], USA360)\n```\n\n\n\n    [          greedy_tsp+opt2: length 26,089 tour (100.0%) in  0.176 secs,\n               divide_tsp+opt2: length 27,108 tour (103.9%) in  4.848 secs,\n                    greedy_tsp: length 28,926 tour (110.9%) in  0.025 secs,\n                    divide_tsp: length 29,177 tour (111.8%) in  4.654 secs]\n\n\n\n    \n![png](TSP_files/TSP_89_1.png)\n    \n\nThe conclusion: `divide_tsp` does not perform as well as `greedy_tsp` on this example, and is much slower.",
      "concepts": [
        "divide-and-conquer",
        "divide-tsp",
        "greedy-tsp",
        "optimization",
        "traveling-salesman-problem"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-55-minimum-spanning-tree-algorithm-introduction",
      "topic": "Introduction to Minimum Spanning Tree Algorithm",
      "text": "# Shoulders of Giants: Minimum Spanning Tree Algorithm\n\n\n| ![Joseph Kruskal (Wikipedia)](http://people.inf.elte.hu/hytruongson/Kruskal/J.Kruskal.jpg) |\n|----|\n| [Joseph Kruskal (Wikipedia)](https://en.wikipedia.org/wiki/Joseph_Kruskal) |\n\n\n\nI hope you now believe that you could have come up with some ideas for solving the TSP, using the set of **strategies**. But even if you can't come up with something all on your own, you can follow the **Stand on the Shoulders of Giants Strategy**, also known as the **[Just Google it Strategy](http://bit.ly/XNGt2y)**, in which case you'll no doubt find a giant of a mathematician, [Joseph Kruskal](http://en.wikipedia.org/wiki/Joseph_Kruskal), who, in 1956, published [a paper](http://www.cmat.edu.uy/~marclan/TAG/Sellanes/Kruskal.pdf) that led to an algorithm that\nmost people would not have thought of on their own (I know I wouldn't have):\n> **Minimum Spanning Tree Traversal Algorithm:** *Construct a Minimum Spanning Tree, then do a pre-order traversal.  That will give you a tour that is guaranteed to be no more than twice as long as the minimal tour.*",
      "concepts": [
        "traveling-salesperson-problem",
        "minimum-spanning-tree-traversal-algorithm",
        "pre-order-traversal"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-56-graph-theory-glossary",
      "topic": "Graph Theory Glossary",
      "text": "What does all this jargon mean? It is part of *[graph theory](https://en.wikipedia.org/wiki/Graph_theory)*, the study of vertexes and links.  Here is a glossary of terms:\n\n* A **graph** is a collection of vertexes and links.\n* A **vertex** is a point (such as a city).\n* A **link** is an edge between two vertexes. Links have lengths.\n* A **directed graph** is a graph where the links have a direction.  We say that the link goes from the **parent** vertex to the **child** vertex.\n* A **tree** is a directed graph in which there is one distinguished vertex called the **root** that has no parent; every other vertex has exactly one parent. \n* A **spanning tree** (of a set of vertexes) is a tree that contains all the vertexes.    \n* A **minimum spanning tree** is a spanning tree with the smallest  sum of link lengths.\n* A **traversal** of a tree is a way of visiting all the vertexes in some order.\n* A **pre-order traversal** means that you visit the root first, then do a pre-order traversal of each of the children.",
      "concepts": [
        "graph-theory",
        "graph",
        "vertex",
        "link",
        "directed-graph",
        "parent-vertex",
        "child-vertex",
        "tree",
        "root",
        "spanning-tree",
        "minimum-spanning-tree",
        "traversal",
        "pre-order-traversal"
      ],
      "chunk_type": "definition"
    },
    {
      "chunk_id": "chunk-57-mst-algorithm-implementation-plan",
      "topic": "Plan for Implementing MST Algorithm",
      "text": "\nWe will implement a directed graph as a dict of `{parent: [child, ...]}`. Now our plan is:\n\n1. Implement an algorithm to create a minimum spanning tree, `mst`.\n2. Implement a tree traversal; that will give us our `mst_tsp` algorithm.\n3. Understand the guarantee.",
      "concepts": [
        "directed-graph",
        "minimum-spanning-tree",
        "tree-traversal",
        "mst-tsp-algorithm"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-58-mst-tsp-introduction",
      "topic": "Introduction to using MST for TSP",
      "text": "# Turning a Minimum Spanning Tree into a Tour (`mst_tsp`)\n\nGiven a minimum spanning tree, we can generate a tour by doing a pre-order traversal, which means the tour starts at the root, then visits all the cities in the pre-order traversal of the first child of the root, followed by the pre-order traversals of any other children.",
      "concepts": [
        "minimum-spanning-tree",
        "traveling-salesperson-problem",
        "pre-order-traversal",
        "mst-tsp"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-59-mst-tsp-implementation",
      "topic": "Implementation of MST TSP algorithm",
      "text": "```python\ndef mst_tsp(cities) -> Tour:\n    \"\"\"Create a minimum spanning tree and walk it in pre-order.\"\"\"\n    return Tour(preorder_traversal(mst(cities), first(cities)))\n\ndef preorder_traversal(tree, root):\n    \"\"\"Traverse tree in pre-order, starting at root of tree.\"\"\"\n    yield root\n    for child in tree.get(root, ()):\n        yield from preorder_traversal(tree, child)\n```\n\nYou can think of this as starting at the root of the tree and going around the outside of the tree, as if you were walking with your hand always touching a link, but skipping cities you have already been to.",
      "concepts": [
        "mst-tsp",
        "minimum-spanning-tree",
        "pre-order-traversal",
        "graph-traversal"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-60-mst-tsp-performance-analysis",
      "topic": "Performance comparison of MST TSP",
      "text": "Let's see what `mst_tsp` can do on the USA map:\n\n\n```python\nruns([mst_tsp], USA)\n```\n\n\n\n    [     rep_opt2_nearest_tsp: length 44,317 tour (100.0%) in 16.662 secs,\n     rep_opt2_nearest_tsp+opt2: length 44,317 tour (100.0%) in 16.995 secs,\n               greedy_tsp+opt2: length 44,417 tour (100.2%) in  2.162 secs,\n          rep_nearest_tsp+opt2: length 44,473 tour (100.4%) in  2.137 secs,\n              nearest_tsp+opt2: length 45,105 tour (101.8%) in  1.768 secs,\n                  mst_tsp+opt2: length 45,250 tour (102.1%) in  2.878 secs,\n                     list+opt2: length 46,460 tour (104.8%) in  2.929 secs,\n               rep_nearest_tsp: length 50,915 tour (114.9%) in  0.798 secs,\n                    greedy_tsp: length 51,129 tour (115.4%) in  0.407 secs,\n                   nearest_tsp: length 53,364 tour (120.4%) in  0.080 secs,\n                       mst_tsp: length 58,201 tour (131.3%) in  0.485 secs,\n                          list: length 1,122,001 tour (2531.8%) in  0.000 secs]\n\n\n\n\n    \n![png](TSP_files/TSP_97_1.png)\n    \n\nWe see that `mst_tsp` performs poorly compared to the other algorithms.\n\nWhy would anyone want to use the minimum spanning tree algorithm, when the nearest neighbor algorithm is simpler to describe, simpler to implement, runs faster, and produces shorter tours?",
      "concepts": [
        "mst-tsp",
        "nearest-neighbor-algorithm",
        "minimum-spanning-tree",
        "algorithm-performance",
        "greedy-tsp",
        "opt2"
      ],
      "chunk_type": "explanation"
    },
    {
      "chunk_id": "chunk-61-guaranteed-tour-length-overview",
      "topic": "Introduction to the guarantee of the minimum spanning tree algorithm",
      "text": "The \"giant\" thing about the minimum spanning tree algorithm is that it comes with a *guarantee*, which none of the other algorithms offer (except for `exhaustive_tsp`, which is guaranteed to find the optimal algorithm, if it has enough time to complete). The algorithm  guarantees that the tour length will be no worse than twice as long as the optimal tour.  (And, with a bit more [complication](https://en.wikipedia.org/wiki/Christofides_algorithm), you can modify it to give a guarantee of 1.5 times longer.)  The guarantee works like this:\n\n1. The minimum spanning tree, by definition, connects all the cities with the shortest possible total link length.\n2. So if you could follow each link in the spanning tree just once, and that formed a legal tour, then that would be guaranteed to be\na minimal tour.  \n3. But you can't do that in general; in general there will be places where you skip to the next city without following the spanning tree.  Any such skip, however, is a straight line, and thus will be less than you would take if you went to the next city by following along the spanning tree.\n4. If you did follow along the spanning tree, you would follow some links twice, and some links once.  Hence the total length of the tour would be at most twice the spanning tree, and thus at most twice the minimal tour.\n\nA guarantee is great from a theoretical point of view, but in practice the greedy or nearest neighbor algorithms almost always do better than the minimum spanning tree,  on the maps that we actually see.",
      "concepts": [
        "minimum-spanning-tree",
        "tour-length-guarantee",
        "optimal-tour",
        "christofides-algorithm",
        "greedy-algorithms",
        "nearest-neighbor-algorithm"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-62-held-karp-algorithm-introduction",
      "topic": "Introduction to the Held-Karp algorithm",
      "text": "Another algorithm that shows up with a literature search is the [Held-Karp Dynamic Programming Algorithm](http://en.wikipedia.org/wiki/Held%E2%80%93Karp_algorithm), named after giants [Michael Held](http://www.computerhistory.org/collections/catalog/102650390) and [Richard Karp](http://en.wikipedia.org/wiki/Richard_M._Karp). It is an algorithm for finding optimal tours, not approximate ones, so it is not appropriate for large *n*.  But even in its simplest form, without any complex programming tricks, it can go quite a bit further than `exhaustive_tsp`.  That is because `exhaustive_tsp` is O(*n*!), while the Held-Karp algorithm is only O(*n*<sup>2</sup> 2<sup>*n*</sup>).  How did Held and Karp achieve this speedup?  They noticed that `exhaustive_tsp` wastes a lot of time with permutations that can't possibly be optimal tours.  Here's the key idea:\n\n- **Key idea**: *Given a start city A, an end city C, and a set of middle cities Bs, then out of all the possible segments that start in A, end in C, and go through all and only the cities in Bs, only the shortest of those segments could ever be part of an optimal tour.*",
      "concepts": [
        "held-karp-algorithm",
        "dynamic-programming",
        "optimal-tour",
        "exhaustive-search",
        "time-complexity"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-63-held-karp-optimization-explanation",
      "topic": "Explanation of the Held-Karp optimization",
      "text": "Of course, we don't know that the optimal tour goes through exactly those Bs cities before hitting C.  But if it does, then we need only consider the permutation of Bs that leads to the shortest segment.  Why is that such a big deal? Suppose we are considering segments of the form:\n\n     [A, {B1, ... B10}, C, {D1, ... D10}, E]\n     \nThat is, segments that start with A, then have have 10 B<sub>i</sub> cities in some order, then C, then 10 D<sub>j</sub> cities in some order, then E. With the Exhaustive Search algorithm, we have to consider all orderings of B<sub>i</sub> and all orderings of D<sub>j</sub>, so overall there would be (10!)<sup>2</sup> &approx; 13 trillion orderings of this form. But with Held-Karp, we consider the B<sub>i</sub> and D<sub>j</sub> separately, and chose the best segment from each, giving us only 2 &times; 10! &approx; 7 million orderings to consider. (Actually it is even better than that, because we use Held-Karp recursively to split the B<sub>i</sub> and D<sub>j</sub> into pieces.)",
      "concepts": [
        "held-karp-algorithm",
        "optimal-tour",
        "exhaustive-search",
        "permutation",
        "segment-optimization"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-64-held-karp-algorithm-definition",
      "topic": "Definition of the Held-Karp algorithm for TSP",
      "text": "So far we have only been talking about segments.  We know that the TSP is defined for tours, not segments. So even if we find the shortest possible segment, it might not be the shortest possible tour.  But here's something we do know: a tour has to end somewhere.  So we have:\n\n- **Held-Karp algorithm**: *Find the shortest segment from the start city, `A`, to each possible end city, `C`, using the key idea above.   Out of those segments, choose the one that is the shortest tour.*",
      "concepts": [
        "held-karp-algorithm",
        "traveling-salesman-problem",
        "shortest-segment",
        "optimal-tour"
      ],
      "chunk_type": "definition",
      "section": null
    },
    {
      "chunk_id": "chunk-65-held-karp-python-implementation",
      "topic": "Python implementation of the Held-Karp algorithm",
      "text": "```python\ndef held_karp_tsp(cities) -> Tour:\n    \"\"\"The Held-Karp shortest tour of this set of cities.\n    For each end city C, find the shortest segment from A (the start) to C.\n    Out of all these shortest segments, pick the one that is the shortest tour.\"\"\"\n    A = first(cities)\n    shortest_segment.cache_clear() # Clear cache for a new problem\n    return shortest(shortest_segment(A, cities - {A, C}, C)\n                    for C in cities - {A})\n```",
      "concepts": [
        "held-karp-algorithm",
        "python",
        "shortest-segment",
        "optimal-tour",
        "traveling-salesman-problem"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-66-shortest-segment-function",
      "topic": "Defining the shortest_segment function",
      "text": "Now for `shortest_segment(A, Bs, C)`, the shortest segment that starts in city `A`, ends in `C`, and visits some permutation of `Bs` cities in the middle.  If there are no `Bs` cities, then of course the shortest segment is to go directly from `A` to `C`.  If there are `Bs` cities, then one of them has to be the last `B` city visited (just before visiting `C`). So for each `B`, find the shortest segment that first goes from `A`, through all the other `Bs` cities, then to `B`, and finally to `C`.  Out of all these candidate segments, return the one with the minimum segment length.\n\n**Note:** the decorator `@cache` makes this a **dynamic programming** algorithm, which is a fancy name meaning that we cache the results of sub-computations because we will re-use them multiple times. In the function `held_karp_tsp` we clear the cache at the start of each new problem.",
      "concepts": [
        "shortest-segment-function",
        "dynamic-programming",
        "caching",
        "held-karp-algorithm"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-67-shortest-segment-implementation",
      "topic": "Implementation of shortest_segment and segment_length",
      "text": "```python\n@cache\ndef shortest_segment(A, Bs, C) -> Segment:\n    \"\"\"The shortest segment starting at A, going through all Bs, and ending at C.\"\"\"\n    if not Bs:\n        return [A, C]\n    else:\n        return min((shortest_segment(A, Bs - {B}, B) + [C] for B in Bs),\n                   key=segment_length)\n            \ndef segment_length(segment):\n    \"\"\"The total of distances between each pair of consecutive cities in the segment.\"\"\"\n    # Same as tour_length, but without distance(tour[0], tour[-1])\n    return sum(distance(segment[i], segment[i-1]) \n               for i in range(1, len(segment)))\n```\n\nThat's all there is to it.  Let's try a run:",
      "concepts": [
        "shortest-segment-function",
        "segment-length-function",
        "caching",
        "dynamic-programming"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-68-held-karp-vs-exhaustive-search-performance",
      "topic": "Comparing performance of Held-Karp and Exhaustive Search",
      "text": "```python\nruns([held_karp_tsp, exhaustive_tsp], random_cities(10), [None])\n```\n\n\n\n    [            held_karp_tsp: length 23,013 tour (100.0%) in  0.040 secs,\n                exhaustive_tsp: length 23,013 tour (100.0%) in  0.973 secs]\n\n\n\n\n    \n![png](TSP_files/TSP_104_1.png)\n    \n\nWe see that `held_karp_tsp` is a lot faster.  We can extend into uncharted territory  beyond the reach of  `exhaustive_tsp`:\n\n```python\nruns([held_karp_tsp], random_cities(15), [None])\n```\n\n\n\n    [            held_karp_tsp: length 26,200 tour (100.0%) in  2.092 secs]\n\n\n\n\n    \n![png](TSP_files/TSP_106_1.png)\n    \n\nNot bad! To see how much time we save using `held_karp_tsp` over `exhaustive_tsp`, we can extrapolate from the timings we've done, using the fact that Held-Karp is *O*(*n*<sup>2</sup> 2<sup>*n*</sup>) while Exhaustive Search is *O*(*n*!), to get this table:\n\n|*n*|Exhaustive Search|Held Karp|\n|---|---|---|\n|10| 2 secs                | 0.04 secs |\n|12|&approx; 4 mins   | 0.25 secs|\n|15|&approx; 8 days |2 secs|\n|25|&approx; <a href=\"https://www.google.com/search?q=2+seconds*25!+%2F+10!+in+years\">270 billion years</a>|&approx; 95 minutes|\n\n\n\nSo if we had the patience to wait 95 minutes, `held_karp_tsp` could give us an answer on a 25-city problem that saves 270 billion years of computing compared to `exhaustive_tsp`.  The original Held-Karp algorithm had refinements that allowed it to handle 50-city sets in hours, not centuries, and could do so even with 1970s-era computing power! See **Branch and Cut** below.",
      "concepts": [
        "held-karp-algorithm",
        "exhaustive-search",
        "time-complexity",
        "branch-and-cut"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-69-tsp-algorithms-review",
      "topic": "Review of TSP Algorithms by Strategy",
      "text": "# Review\n\nHere are the algorithms we developed, grouped by strategy:\n\n- **Brute Force Strategy**: `exhaustive_tsp`\n- **Greedy Strategy**: `nearest_tsp`, `greedy_tsp`\n- **Ensemble Strategy**: `rep_nearest_tsp`, `rep_opt2_nearest_tsp`\n- **Improvement Strategy**: `opt2`\n- **Divide and Conquer Strategy**: `divide_tsp`\n- **Giant Shoulders Strategy**: `mst_tsp`, `held_karp_tsp`",
      "concepts": [
        "tsp-algorithms",
        "brute-force-strategy",
        "exhaustive-tsp",
        "greedy-strategy",
        "nearest-tsp",
        "greedy-tsp",
        "ensemble-strategy",
        "rep-nearest-tsp",
        "rep-opt2-nearest-tsp",
        "improvement-strategy",
        "opt2",
        "divide-and-conquer-strategy",
        "divide-tsp",
        "giant-shoulders-strategy",
        "mst-tsp",
        "held-karp-tsp"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-70-benchmark-experiments-introduction",
      "topic": "Introduction to benchmarking algorithms",
      "text": "# Benchmark Experiments on Algorithms\n\nWhich algorithm is best? I can't tell by trying them on only one or two problems. What I need to do is **benchmark** each algorithm on a standard **test set** of problems, and look at **statistical tests** to compare the algorithms. If the test set is large enough, the results will have statistical significance. If the test set is representative of the problems we want to solve, the results will have relevance. I'll build the following tools:\n- `test_set`: A function to build a test set of *s* random sets of cities, each set with *n* cities.\n- `benchmark`: A function to run an algorithm on a test set and record the results.\n- `boxplots`: A function to plot the benchmark results of several algorithms.\n- `rankings`: A function to print results of how many time each algorithm had the shortest tour, the second shortest, etc.\n\nFirst the test sets:",
      "concepts": [
        "benchmark",
        "test-set",
        "statistical-tests",
        "statistical-significance",
        "relevance"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-71-test-set-function-definition",
      "topic": "Definition of the test_set function",
      "text": "```python\nTestSet = Tuple[Cities]\n\ndef test_set(s: int, n: int) -> TestSet:\n    \"\"\"Return `s` different sets of `n` random cities.\"\"\"\n    return tuple(random_cities(n, seed=(s, i)) for i in range(s))\n```",
      "concepts": [
        "test-set",
        "random-cities"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-72-benchmark-function-definition",
      "topic": "Definition of the benchmark function",
      "text": "Next, the function `benchmark` takes as input a TSP function and a test set. It does a `run` of the function on each problem in the test set (possibly passing along `opt` and `kwds` values), and returns the list of `run` results. \n\n\n```python\n@cache\ndef benchmark(algorithm, tests, opt=None, **kwds) -> List[run]:\n    \"\"\"Benchmark one TSP algorithm on a test suite; return a list of `run`s.\"\"\"\n    return [run(algorithm, test, opt=opt, **kwds) for test in tests]\n```",
      "concepts": [
        "benchmark",
        "tsp-function",
        "test-set",
        "run"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-73-boxplot-function-definition",
      "topic": "Definition of the boxplots function",
      "text": "A **boxplot** is a standard statistical visualization tool. I'll explain them when we see the output.\n\n\n```python\ndef boxplots(algorithms, tests: TestSet, opt=None, **kwds):\n    \"\"\"Draw a boxplot for each of the algorithms executing the tests.\"\"\"\n    runslists = [benchmark(tsp, tests, opt=opt, **kwds) for tsp in algorithms]\n    lengthlists = [[length(r) for r in runs] for runs in runslists]\n    timelists   = [[r.secs for r in runs] for runs in runslists]\n    best   = min(map(mean, lengthlists))\n    labels = [boxplot_label(A, L, T, best) for (A, L, T) in zip(algorithms, lengthlists, timelists)]\n    plt.figure(figsize=(15, 7.5))\n    plt.grid(axis='y'); plt.ylabel('Mean Tour Length')\n    plt.tick_params(axis='x', which='major', labelsize=12)\n    plt.boxplot(lengthlists, labels=labels, showmeans=True, whis=(10, 90), sym='o', notch=True)\n    plt.title(f\"{len(tests)} sets of {len(tests[0])} cities with {opt.__name__ if opt else 'no'} optimization\")\n\ndef boxplot_label(tsp, lengths, times, best):\n    \"\"\"A label for the bottom of the boxplot.\"\"\"\n    return '{}\\n{:.0f} ± {:.1f} msec\\n{:,d} med len\\n{:,d} ± {:,d} mean\\n{:.2%} mean'.format(\n           name(tsp), mean(times) * 1000, stdev(times) * 1000, \n           round(median(lengths)), round(mean(lengths)), round(stdev(lengths)), mean(lengths) / best)\n\ndef unzip(sequences): return zip(*sequences)\n```",
      "concepts": [
        "boxplot",
        "statistical-visualization",
        "benchmark",
        "tsp",
        "mean-tour-length",
        "median",
        "standard-deviation"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-74-rankings-function-definition",
      "topic": "Definition of the rankings function",
      "text": "`rankings` produces a table comparing how many times each algorithm was best, second best etc., on a city-set.\n\n\n```python\ndef rankings(algorithms, tests: TestSet, opt=None, **kwds):\n    \"\"\"Print a table of how often each algorithm had each rank: you get a #1 if you were shortest.\"\"\"\n    N = len(algorithms)\n    runslists = [benchmark(tsp, tests, opt=opt, **kwds) for tsp in algorithms]\n    lengthlists = [[round(length(r)) for r in runs] for runs in runslists]\n    # ordered[i] is all tour lengths (for all algorithms) for the i-th problem, sorted\n    ordered = [sorted(L) for L in zip(*lengthlists)]\n    fmt = ('{:>4}' * len(algorithms) + ' | {}').format\n    print(fmt(*['#' + str(i + 1) for i in range(N)], 'Algorithm'))\n    print(' ---' * N + ' | ---------')\n    for alg, lengths in zip(algorithms, lengthlists):\n        ranks = Counter(ordered[i].index(lengths[i]) for i in range(len(tests)))\n        print(fmt(*[ranks[i] for i in range(N)], name(alg)))\n```",
      "concepts": [
        "rankings",
        "algorithm-comparison",
        "benchmark",
        "tsp",
        "tour-length"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-75-compare-function-definition",
      "topic": "Definition of the compare function",
      "text": "Finally, the function `compare` does both `rankings` and `boxplots`:\n\n\n```python\ndef compare(algorithms, tests=test_set(50, 200), opt=None):\n    \"\"\"Compare algorithms with boxplots and rankings.\"\"\"\n    rankings(algorithms, tests, opt=opt)\n    boxplots(algorithms, tests, opt=opt)\n```",
      "concepts": [
        "compare",
        "rankings",
        "boxplots",
        "algorithm-comparison"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-76-benchmarks-introduction",
      "topic": "Introduction to benchmarking approximate TSP algorithms",
      "text": "# The Benchmarks\n\nWe'll start by comparing the 5 approximate algorithms on the default test set of 50 sets of 200 cities each:\n\n",
      "concepts": [
        "benchmarking",
        "approximate-algorithms",
        "traveling-salesperson-problem"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-77-initial-algorithm-comparison",
      "topic": "Comparing TSP algorithms without optimization",
      "text": "```python\ntsps = [nearest_tsp, rep_nearest_tsp, greedy_tsp, divide_tsp, mst_tsp]\n\ncompare(tsps)\n```\n\n      #1  #2  #3  #4  #5 | Algorithm\n     --- --- --- --- --- | ---------\n       1   5   5  38   1 | nearest_tsp\n       9  17  23   1   0 | rep_nearest_tsp\n      24  11  10   5   0 | greedy_tsp\n      16  17  11   6   0 | divide_tsp\n       0   0   1   0  49 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_119_1.png)\n    \n\nThe rankings tell us that the middle three algorithms each perform well in the rankings. Of the 50 city-sets, `rep_nearest_tsp` is best 9 times (and second-best 17 times), `greedy_tsp` is best 24 times, and `divide_tsp` best 16 times. `nearest_tsp` does consistently worse than `rep_nearest_tsp`, as expected, and `mst_tsp` finishes last 49 times out of 50.",
      "concepts": [
        "nearest-neighbor-algorithm",
        "repetitive-nearest-neighbor-algorithm",
        "greedy-algorithm",
        "divide-and-conquer-algorithm",
        "minimum-spanning-tree-algorithm",
        "traveling-salesperson-problem"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-78-boxplot-explanation",
      "topic": "Explanation of the boxplot and algorithm performance",
      "text": "In the boxplot, each column represents a data set (in this case, the 50 tour lengths for one algorithm) with a box covering the first to third quartiles of the data; inside the box is a horizontal line indicating the median and a triangle marker indicating the mean. The 10% and 90%  intervals are the \"whiskers\" coming out of the top and bottom of the box, and individual points outside that range are shown as dots. The \"notches\" in the sides of a boxes represent the 95% confidence interval on the median: if two boxes' notches do not overlap, that is strong evidence that the true medians of the algorithms differ. The label at the bottom of each column gives the name of the algorithm, the average run time in milliseconds (± standard deviation), the mean and median tour length (± standard deviation), and the percentage that the mean tour length of this algorithm is compared to the mean tour length of the best algorithm in this boxplot.\n\nThis boxplot says that the middle three algorithms all did about the same in tour length; their notches overlap, so we can't be confident that one is better than the others. (Although we can be confident that the greedy algorithm is the fastest of the three, especially compared to `divide_tsp`, and that `nearest_tsp` is faster still.) The minimum spanning tree algorithm produces by far the longest tours.",
      "concepts": [
        "boxplot",
        "quartiles",
        "median",
        "mean",
        "confidence-interval",
        "nearest-neighbor-algorithm",
        "greedy-algorithm",
        "divide-and-conquer-algorithm",
        "minimum-spanning-tree-algorithm"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-79-algorithm-comparison-with-opt2",
      "topic": "Comparing TSP algorithms with opt2 optimization",
      "text": "Now let's repeat the benchmark with `opt2` applied to each result:\n\n```python\ncompare(tsps, opt=opt2)\n```\n\n      #1  #2  #3  #4  #5 | Algorithm\n     --- --- --- --- --- | ---------\n       5  13  13  14   5 | nearest_tsp\n      13  16   8  12   1 | rep_nearest_tsp\n      29  12   7   2   0 | greedy_tsp\n       0   2   2   5  41 | divide_tsp\n       3   7  20  17   3 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_121_1.png)\n    \n\nThis is interesting. Now `greedy_tsp` has increased its lead over `rep_nearest_tsp`, and `divide_tsp` is out of contention. Apparently, it is hard for `opt2` to optimize the types of tours produced by `divide_tsp`. On the other hand, `opt2` seems to have an easy time optimizing `mst_tsp`.\n\nAs far as run time goes, note that `greedy_tsp` is now faster than `nearest_tsp`, reversing the previous comparison. It seems that `opt2` runs faster on the tours produced by `greedy_tsp`. It should not be surprising that the speed of `opt2` depends on the tour; `opt2` has a `while` loop that will repeat a different number of times for different tours.",
      "concepts": [
        "nearest-neighbor-algorithm",
        "repetitive-nearest-neighbor-algorithm",
        "greedy-algorithm",
        "divide-and-conquer-algorithm",
        "minimum-spanning-tree-algorithm",
        "2-opt",
        "local-search",
        "optimization"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-80-ensemble-strategy-introduction",
      "topic": "Introduction to the ensemble strategy for TSP",
      "text": "Since no one algorithm always dominates the others, maybe it is time for the **ensemble strategy**: try a bunch of TSP algorithms and choose the best tour that the bunch produces. There is a tradeoff of how much time you want to spend on this; I've included in the ensemble only the three algorithms with the best combination of short tours and fast run times on the benchmarks above.",
      "concepts": [
        "ensemble-strategy",
        "traveling-salesperson-problem",
        "tsp-algorithms"
      ],
      "chunk_type": "overview",
      "section": null
    },
    {
      "chunk_id": "chunk-81-ensemble-tsp-implementation",
      "topic": "Implementation of the ensemble_tsp function",
      "text": "```python\nensemble = [rep_nearest_tsp, greedy_tsp, mst_tsp]\n\ndef ensemble_tsp(cities, algorithms=ensemble, opt=opt2): \n    \"\"\"Apply an ensemble of algorithms to cities and take the shortest resulting tour.\"\"\"\n    return shortest(run(tsp, cities, opt=opt).tour for tsp in algorithms)\n```\n\nThe ensemble is doing more work, so I'll use a somewhat smaller test set.",
      "concepts": [
        "ensemble-strategy",
        "ensemble-tsp-function",
        "rep-nearest-tsp",
        "greedy-tsp",
        "mst-tsp",
        "shortest-tour"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-82-ensemble-tsp-comparison",
      "topic": "Comparing ensemble_tsp with other TSP algorithms",
      "text": "```python\ncompare([ensemble_tsp] + ensemble, test_set(40, 200), opt=opt2)\n```\n\n      #1  #2  #3  #4 | Algorithm\n     --- --- --- --- | ---------\n      40   0   0   0 | ensemble_tsp\n      12   0  17  11 | rep_nearest_tsp\n      24   0  10   6 | greedy_tsp\n       4   0  13  23 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_126_1.png)\n    \n\nFor the rankings, note that there are only 40 problems, but 80 entries in the `#1` column. That's because for ties, the co-winners both appear in the `#1` column, and by definition, the `ensemble_tsp` will always tie with one of the components of the ensemble. All three component algorithms contribute to the ensemble.\n\nFor tour lengths, `ensemble_tsp` is the best (by definition), but only by a small amount. Is it worth it to more than triple the run time to get less than a 1% improvement in tour length over `greedy_tsp` alone?",
      "concepts": [
        "ensemble-strategy",
        "ensemble-tsp-function",
        "rep-nearest-tsp",
        "greedy-tsp",
        "mst-tsp",
        "algorithm-comparison",
        "tour-length",
        "runtime-analysis"
      ],
      "chunk_type": "explanation",
      "section": null
    },
    {
      "chunk_id": "chunk-83-city-set-size-comparison",
      "topic": "Comparing TSP algorithms with different city set sizes",
      "text": "Let's see if the results are different for different-sized city sets. We had been doing 50 samples of 200-city sets; let's try 40 samples of 500-city sets. I'll just look at the three top (individual) algorithms, with `opt2` optimization:\n\n```python\ncompare(ensemble, test_set(40, 500), opt=opt2)\n```\n\n      #1  #2  #3 | Algorithm\n     --- --- --- | ---------\n       7  29   4 | rep_nearest_tsp\n      32   7   1 | greedy_tsp\n       1   4  35 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_129_1.png)\n    \n\nAt this size `greedy_tsp` is a more clear winner.",
      "concepts": [
        "traveling-salesperson-problem",
        "tsp-algorithms",
        "city-sets",
        "opt2-optimization",
        "greedy-tsp",
        "rep_nearest_tsp",
        "mst_tsp"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-84-usa-map-city-sampling",
      "topic": "Testing TSP algorithms with cities sampled from the USA map",
      "text": "What if the samples were not picked randomly from the 2-D plane, but rather from the USA map?\n\n\n```python\nUSA_test_set = tuple(Cities(sample(USA, 500, i)) for i in range(40))\n\ncompare(ensemble, USA_test_set, opt=opt2)\n```\n\n      #1  #2  #3 | Algorithm\n     --- --- --- | ---------\n      12  15  13 | rep_nearest_tsp\n      25  11   4 | greedy_tsp\n       3  14  23 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_131_1.png)\n    \n\n`greedy_tsp` still has the lead.",
      "concepts": [
        "traveling-salesperson-problem",
        "tsp-algorithms",
        "city-sampling",
        "usa-map",
        "opt2-optimization",
        "greedy-tsp",
        "rep_nearest_tsp",
        "mst_tsp"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-85-1000-city-set-comparison",
      "topic": "Comparing TSP algorithms with 1000-city sets",
      "text": "What happens when we go up to 1,000-city sets?\n\n\n```python\ncompare(ensemble, test_set(20, 1000), opt=opt2)\n```\n\n      #1  #2  #3 | Algorithm\n     --- --- --- | ---------\n       1  18   1 | rep_nearest_tsp\n      19   1   0 | greedy_tsp\n       0   1  19 | mst_tsp\n\n\n\n    \n![png](TSP_files/TSP_133_1.png)\n    \n\nWe get a similar picture, with `greedy_tsp` showing an even bigger lead. I'll stop here.",
      "concepts": [
        "traveling-salesperson-problem",
        "tsp-algorithms",
        "city-sets",
        "opt2-optimization",
        "greedy-tsp",
        "rep_nearest_tsp",
        "mst_tsp"
      ],
      "chunk_type": "example",
      "section": null
    },
    {
      "chunk_id": "chunk-86-benchmarking-exact-algorithms-introduction",
      "topic": "Introduction to benchmarking exact TSP algorithms",
      "text": "# Benchmarking Exact Algorithms\n\nHere I compare the two exact algorithms, Exhaustive Search and Held-Karp, to the (approximate) ensemble algorithm. I'll try both 9 and 10-city test suites:",
      "concepts": [
        "benchmarking",
        "exact-algorithms",
        "exhaustive-search",
        "held-karp-algorithm",
        "ensemble-algorithm",
        "traveling-salesman-problem"
      ],
      "chunk_type": "overview"
    },
    {
      "chunk_id": "chunk-87-nine-city-test-suite-comparison",
      "topic": "Comparison of algorithms on a 9-city test suite",
      "text": "```python\ncompare([exhaustive_tsp, held_karp_tsp, ensemble_tsp], test_set(50, 9))\n```\n\n      #1  #2  #3 | Algorithm\n     --- --- --- | ---------\n      50   0   0 | exhaustive_tsp\n      50   0   0 | held_karp_tsp\n      43   0   7 | ensemble_tsp\n\n\n\n    \n![png](TSP_files/TSP_135_1.png)",
      "concepts": [
        "exhaustive-search",
        "held-karp-algorithm",
        "ensemble-algorithm",
        "test-suite",
        "algorithm-comparison"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-88-ten-city-test-suite-comparison",
      "topic": "Comparison of algorithms on a 10-city test suite",
      "text": "```python\ncompare([exhaustive_tsp, held_karp_tsp, ensemble_tsp], test_set(30, 10))\n```\n\n      #1  #2  #3 | Algorithm\n     --- --- --- | ---------\n      30   0   0 | exhaustive_tsp\n      30   0   0 | held_karp_tsp\n      29   0   1 | ensemble_tsp\n\n\n\n    \n![png](TSP_files/TSP_136_1.png)",
      "concepts": [
        "exhaustive-search",
        "held-karp-algorithm",
        "ensemble-algorithm",
        "test-suite",
        "algorithm-comparison"
      ],
      "chunk_type": "example"
    },
    {
      "chunk_id": "chunk-89-ensemble-algorithm-performance-analysis",
      "topic": "Analysis of the ensemble algorithm's performance",
      "text": "This says that while `ensemble_tsp` does not give a guarantee of an optimal tour, in practice on small random city sets it performs almost as well as the exact algorithms (within 0.1%), only much faster.",
      "concepts": [
        "ensemble-algorithm",
        "optimal-tour",
        "performance-analysis",
        "exact-algorithms",
        "time-complexity"
      ],
      "chunk_type": "explanation"
    },
    {
      "chunk_id": "chunk-90-further-explorations-overview",
      "topic": "Further Explorations and Open Questions",
      "text": "# Further Explorations\n\n\nThat's all I'm going to write for now.  But there are still plenty of open questions for you to explore:\n\n* **Branch and Cut**: this is a technique to cut off a search early, when a partial solution is obviously not optimal.  We saw how Held-Karp cuts off some permutations of cities when another permutation is better.  A refinement on that is to keep track of, say, the best total length of the segment going through all the Bs cities.  Then, any time you have a partial segment through some of the Bs cities that exceeds the best total, we can stop right there, before even finishing all the Bs.  With this technique, you can find optimal tours for around 50 cities.\n* **Linear programming**: Look up the topic \"linear programming\" and see how it applies to TSP.\n* **Heuristic Algorithms**: There are many approaches for using heurisitic estimates to find good (but not optimal) tours.  For example, *ant colony optimization algorithms* make random choices of which link to follow, and then the links that occur in the best tours get reinforced with some virtual pheromones, and other ants tend to follow those pheromones. *Simulated annealing* takes its inspiration from metallurgy.\n* The **[Lin-Kernighan heuristic](http://akira.ruc.dk/~keld/research/LKH/LKH-1.3/DOC/LKH_REPORT.pdf)** is a generalization of `opt2` that can split the tour into more than two pieces, and considers all ways to put it back together. With such tricks, approximate algorithms  can handle hundreds of thousands of cities and come within 0.01% of the shortest possible tour.\n* The **[Christofides algorithm](https://en.wikipedia.org/wiki/Christofides_algorithm)** gives a guarantee of 3/2 the optimal tour length (improving on the minimum-spanning-tree guarantee of 2).\n* Can you explain why `mst_tsp` produces a guaranteed result, while `greedy_tsp` does not, even though the two algorithms have similar structure in the way they iterate over `shortest_links_first`?\n* The code in this notebook was designed for clarity, not efficiency.  Can you make the code faster?\n* **[William Cook](https://www.math.uwaterloo.ca/~bico/)** has a comprehensive \n[web page](http://www.math.uwaterloo.ca/tsp/) on the TSP, as well as a great \n[book](https://press.princeton.edu/titles/9531.html) and a\n[draft chapter](http://www.math.uwaterloo.ca/~bico/papers/comp_chapter1.pdf) on Discrete Optimization featuring TSP. Like my notebook here, Cook's chapter goes through a variety of algorithms for TSP, describing each one in prose and code. His coding style is different because he uses C (in an imperative style) while I used Python (in a mostly functional style).  His code is much more efficient (but if it is 100 times faster, that might only mean two more cities on `exhaustive_tsp`). Cook  chooses a different set of algorithms to explore, with\nmore emphasis on optimizing algorithms that find guaranteed shortest tours. I find his explanations and code\nare both beautiful and concise, and I think it is very interesting that\nthere can be two quite different approaches, which (in my opinion) both turn out very well. \n* If you are heavily into math, there's a [taxonomy](http://cstheory.stackexchange.com/questions/9241/approximation-algorithms-for-metric-tsp) of solutions.\n* What else are you interested in?",
      "concepts": [
        "branch-and-cut",
        "held-karp",
        "linear-programming",
        "heuristic-algorithms",
        "ant-colony-optimization",
        "simulated-annealing",
        "lin-kernighan-heuristic",
        "christofides-algorithm",
        "minimum-spanning-tree",
        "greedy-algorithms",
        "discrete-optimization",
        "exhaustive-search"
      ],
      "chunk_type": "overview",
      "section": null
    }
  ],
  "metadata": {
    "total_chunks": 90,
    "source_file": "tsp.md",
    "chunked_at": "2025-10-30T07:51:32.661Z"
  }
}